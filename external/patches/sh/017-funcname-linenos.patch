diff --git external/sh/error.c external/sh/error.c
index a69f42ab8..64922067e 100644
--- external/sh/error.c
+++ external/sh/error.c
@@ -59,6 +59,7 @@ struct jmploc *handler;
 volatile sig_atomic_t exception;
 volatile sig_atomic_t suppressint;
 volatile sig_atomic_t intpending;
+int errlinno;
 
 
 void verrorwithstatus(int, const char *, va_list) __printf0like(2, 0) __dead2;
@@ -123,21 +124,27 @@ onint(void)
 void
 vwarning(const char *msg, va_list ap)
 {
-	const char *funcname;
+	const char *funcname, *funcnamestack;
 
-	funcname = lookupvar("FUNCNAMESTACK");
-	if (funcname == NULL)
+	funcnamestack = lookupvar("FUNCNAMESTACK");
+	if (funcnamestack == NULL)
 		funcname = lookupvar("FUNCNAME");
+	else
+		funcname = funcnamestack;
 	if (commandname)
-		outfmt(out2, "Error: (%d) %s:%s%s%d: ", getpid(), commandname,
+		outfmt(out2, "Error: (%d) %s%s%s%s%d: ", getpid(),
+		    funcnamestack == NULL ? commandname : "",
+		    funcnamestack == NULL ? ":" : "",
 		    funcname != NULL ? funcname : "",
 		    funcname != NULL ? ":" : "",
-		    plinno);
+		    errlinno);
 	else if (arg0) {
-		outfmt(out2, "Error: (%d) %s:%s%s%d: ", getpid(), arg0,
+		outfmt(out2, "Error: (%d) %s%s%s%s%d: ", getpid(),
+		    funcnamestack == NULL ? arg0 : "",
+		    funcnamestack == NULL ? ":" : "",
 		    funcname != NULL ? funcname : "",
 		    funcname != NULL ? ":" : "",
-		    plinno);
+		    errlinno);
 	}
 	doformat(out2, msg, ap);
 	out2fmt_flush("\n");
diff --git external/sh/error.h external/sh/error.h
index cb64ec85c..b72c4964a 100644
--- external/sh/error.h
+++ external/sh/error.h
@@ -55,6 +55,7 @@ extern volatile sig_atomic_t exception;
 #define EXERROR 1	/* a generic error with exitstatus */
 #define EXEXIT 2	/* call exitshell(exitstatus) */
 
+extern int errlinno;
 
 /*
  * These macros allow the user to suspend the handling of interrupt signals
diff --git external/sh/eval.c external/sh/eval.c
index d74cd1857..13fa4b28a 100644
--- external/sh/eval.c
+++ external/sh/eval.c
@@ -186,6 +186,7 @@ evaltree(union node *n, int flags)
 	int do_etest;
 	union node *next;
 	struct stackmark smark;
+	const int saveerrlinno = errlinno;
 
 	setstackmark(&smark);
 	do_etest = 0;
@@ -226,6 +227,7 @@ evaltree(union node *n, int flags)
 		case NSUBSHELL:
 			evalsubshell(n, flags);
 			do_etest = !(flags & EV_TESTED);
+			errlinno = n->nredir.linno;
 			break;
 		case NBACKGND:
 			evalsubshell(n, flags);
@@ -277,10 +279,12 @@ evaltree(union node *n, int flags)
 		case NPIPE:
 			evalpipe(n);
 			do_etest = !(flags & EV_TESTED);
+			errlinno = n->npipe.linno;
 			break;
 		case NCMD:
 			evalcommand(n, flags, (struct backcmd *)NULL);
 			do_etest = !(flags & EV_TESTED);
+			errlinno = n->ncmd.linno;
 			break;
 		default:
 			out1fmt("Node type = %d\n", n->type);
@@ -303,6 +307,7 @@ out:
 	}
 	if (flags & EV_EXIT)
 		exraise(EXEXIT);
+	errlinno = saveerrlinno;
 }
 
 
@@ -922,12 +927,54 @@ safe_builtin(int idx, int argc, char **argv)
 	return (0);
 }
 
+int in_trap(void);
+static void
+setfuncnamestack(const char *commandname, const union node *cmd,
+    const int linno)
+{
+	const char *funcnamestack, *funcstackset;
+	char *funcstack;
+
+	mklocal("FUNCNAMESTACK");
+	if (funcnest > 1) {
+		funcnamestack = lookupvar("FUNCNAMESTACK");
+		/* It may have been unset purposefully. */
+		if (funcnamestack == NULL) {
+			funcnamestack = lookupvar("FUNCNAME");
+		}
+	} else {
+		funcnamestack = arg0;
+	}
+	INTOFF;
+	if (funcnamestack != NULL) {
+		asprintf(&funcstack, "%s:%d:%s",
+		    funcnamestack,
+		    linno,
+		    commandname);
+		funcstackset = funcstack;
+	} else {
+		/*
+		 * The caller insists on making the child appear to be
+		 * a fresh stack.
+		 */
+		funcstackset = commandname;
+		funcstack = NULL;
+	}
+	/* Avoid SIGPIPE from trap. */
+	if (!in_trap())
+		xtracestr("FUNCNAMESTACK=%s", funcstackset);
+	setvar("FUNCNAMESTACK", funcstackset, 0);
+	free(funcstack);
+	mklocal("FUNCNAME");
+	setvar("FUNCNAME", commandname, 0);
+	INTON;
+}
+
 /*
  * Execute a simple command.
  * Note: This may or may not return if (flags & EV_EXIT).
  */
 
-int in_trap(void);
 static void
 evalcommand(union node *cmd, int flags, struct backcmd *backcmd)
 {
@@ -957,6 +1004,9 @@ evalcommand(union node *cmd, int flags, struct backcmd *backcmd)
 #ifndef NDEBUG
 	int savesuppressint;
 #endif
+	const int saveerrlinno = errlinno;
+
+	errlinno = cmd->ncmd.linno;
 
 	/* First expand the arguments. */
 	TRACE(("evalcommand(%p, %d) called\n", (void *)cmd, flags));
@@ -1158,45 +1208,14 @@ evalcommand(union node *cmd, int flags, struct backcmd *backcmd)
 			shellparam = saveparam;
 			funcnest--;
 			handler = savehandler;
+			errlinno = saveerrlinno;
 			longjmp(handler->loc, 1);
 		}
 		handler = &jmploc;
 		funcnest++;
-		mklocal("FUNCNAME");
-		setvar("FUNCNAME", argv[0], 0);
-		{
-			char *funcstack;
-			int exitstatus_save = exitstatus, oexitstatus_save = oexitstatus;
-			mklocal("FUNCNAMESTACK");
-			if (funcnest > 1) {
-				const char *funcnamestack;
-
-				funcnamestack = lookupvar("FUNCNAMESTACK");
-				assert(funcnamestack != NULL);
-				/*
-				 * Adding line number in for this would
-				 * require work similar to what was done
-				 * in dash commit 5bb39bb1995 and 0df96793e.
-				 */
-				asprintf(&funcstack, "%s:%s",
-				    funcnamestack,
-				    argv[0]);
-			} else {
-				asprintf(&funcstack, "%s:%d:%s",
-				    arg0,
-				    plinno,
-				    argv[0]);
-			}
-			/* Avoid SIGPIPE from trap. */
-			if (!in_trap())
-				xtracestr("FUNCNAMESTACK=%s", funcstack);
-			setvar("FUNCNAMESTACK", funcstack, 0);
-			assert(is_int_on());
-			exitstatus = exitstatus_save;
-			oexitstatus = oexitstatus_save;
-			free(funcstack);
-		}
 		redirect(cmd->ncmd.redirect, REDIR_PUSH);
+		setfuncnamestack(argv[0], cmd, cmd->ncmd.linno);
+		assert(is_int_on());
 		INTON;
 		for (i = 0; i < varlist.count; i++)
 			mklocal(varlist.args[i]);
@@ -1335,6 +1354,7 @@ out:
 		setvar("_", lastarg, 0);
 	if (do_clearcmdentry)
 		clearcmdentry();
+	errlinno = saveerrlinno;
 }
 
 
diff --git external/sh/nodetypes external/sh/nodetypes
index 1507a7ae8..e1765d960 100644
--- external/sh/nodetypes
+++ external/sh/nodetypes
@@ -53,16 +53,19 @@ NSEMI nbinary			# two commands separated by a semicolon
 
 NCMD ncmd			# a simple command
 	type	  int
+	linno	  int
 	args	  nodeptr		# the arguments
 	redirect  nodeptr		# list of file redirections
 
 NPIPE npipe			# a pipeline
 	type	  int
+	linno	  int
 	backgnd	  int			# set to run pipeline in background
 	cmdlist	  nodelist		# the commands in the pipeline
 
 NREDIR nredir			# redirection (of a complex command)
 	type	  int
+	linno	  int
 	n	  nodeptr		# the command
 	redirect  nodeptr		# list of file redirections
 
diff --git external/sh/parser.c external/sh/parser.c
index 0c1b7a91c..4012a6562 100644
--- external/sh/parser.c
+++ external/sh/parser.c
@@ -376,6 +376,8 @@ pipeline(void)
 		pipenode = (union node *)stalloc(sizeof (struct npipe));
 		pipenode->type = NPIPE;
 		pipenode->npipe.backgnd = 0;
+		pipenode->npipe.linno = plinno;
+		/* fprintf(stderr, "NPIPE %d\n", pipenode->npipe.linno); */
 		lp = (struct nodelist *)stalloc(sizeof (struct nodelist));
 		pipenode->npipe.cmdlist = lp;
 		lp->n = n1;
@@ -565,6 +567,8 @@ command(void)
 		n1->type = NSUBSHELL;
 		n1->nredir.n = list(0);
 		n1->nredir.redirect = NULL;
+		n1->nredir.linno = plinno;
+		/* fprintf(stderr, "NREDIR %d\n", n1->nredir.linno); */
 		consumetoken(TRP);
 		checkkwd = CHKKWD | CHKALIAS;
 		is_subshell = 1;
@@ -625,6 +629,7 @@ simplecmd(union node **rpp, union node *redir)
 	union node *n = NULL;
 	int special;
 	int savecheckkwd;
+	const int saveplinno = plinno;
 
 	/* If we don't have any redirections already, then we must reset */
 	/* rpp to be the address of the local redir variable.  */
@@ -689,6 +694,8 @@ simplecmd(union node **rpp, union node *redir)
 	n->type = NCMD;
 	n->ncmd.args = args;
 	n->ncmd.redirect = redir;
+	n->ncmd.linno = saveplinno;
+	/* fprintf(stderr, "NCMD %s:%d\n", n->ncmd.args->narg.text, n->ncmd.linno); */
 	return n;
 }
 
